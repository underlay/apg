import { xsd } from "n3.ts";
import * as ns from "./namespace.js";
// The objects constructed here are extremely sensitive to order, etc.
// Do NOT edit this file unless you absolutely know what you are doing.
// The six labels in the expression schema are:
// 0. case
// 1. element
// 2. expression
// 3. match
// 4. path
// 5. tuple
// We have to define them in alphabetical order.
// 0. case
const caseComponentKeyValue = Object.freeze({ type: "iri" });
const caseComponentKey = Object.freeze({
    type: "component",
    key: ns.key,
    value: caseComponentKeyValue,
});
const caseComponentValueValue = Object.freeze({
    type: "reference",
    value: 2,
});
const caseComponentValue = Object.freeze({
    type: "component",
    key: ns.value,
    value: caseComponentValueValue,
});
const caseValue = Object.freeze({
    type: "product",
    components: [caseComponentKey, caseComponentValue],
});
Object.freeze(caseValue.components);
const caseLabel = Object.freeze({
    type: "label",
    key: ns.CASE,
    value: caseValue,
});
// 1. element
const elementComponentKeyValue = Object.freeze({ type: "iri" });
const elementComponentKey = Object.freeze({
    type: "component",
    key: ns.key,
    value: elementComponentKeyValue,
});
const elementComponentSourceValue = Object.freeze({
    type: "reference",
    value: 5,
});
const elementComponentSource = Object.freeze({
    type: "component",
    key: ns.source,
    value: elementComponentSourceValue,
});
const elementComponentValueValue = Object.freeze({
    type: "reference",
    value: 2,
});
const elementComponentValue = Object.freeze({
    type: "component",
    key: ns.value,
    value: elementComponentValueValue,
});
const elementValueComponents = [
    elementComponentKey,
    elementComponentSource,
    elementComponentValue,
];
Object.freeze(elementValueComponents);
const elementValue = Object.freeze({
    type: "product",
    components: elementValueComponents,
});
const elementLabel = Object.freeze({
    type: "label",
    key: ns.element,
    value: elementValue,
});
// 2. expression
// 2.0 constant
const expressionOptionConstantComponents = [
    {
        type: "component",
        key: ns.datatype,
        value: Object.freeze({ type: "iri" }),
    },
    {
        type: "component",
        key: ns.value,
        value: Object.freeze({ type: "literal", datatype: xsd.string }),
    },
];
Object.freeze(expressionOptionConstantComponents);
for (const component of expressionOptionConstantComponents) {
    Object.freeze(component);
}
const expressionOptionConstant = Object.freeze({
    type: "product",
    components: expressionOptionConstantComponents,
});
// 2.1 id
const expressionOptionId = Object.freeze({ type: "iri" });
// 2.2 injection
const expressionOptionInjectionComponents = [
    {
        type: "component",
        key: ns.key,
        value: Object.freeze({ type: "iri" }),
    },
    {
        type: "component",
        key: ns.value,
        value: Object.freeze({ type: "reference", value: 2 }),
    },
];
Object.freeze(expressionOptionInjectionComponents);
for (const component of expressionOptionInjectionComponents) {
    Object.freeze(component);
}
const expressionOptionInjection = Object.freeze({
    type: "product",
    components: expressionOptionInjectionComponents,
});
// 2.3 node
const expressionOptionNode = Object.freeze({ type: "unit" });
// 2.4 path
const expressionOptionPath = Object.freeze({
    type: "reference",
    value: 4,
});
// 2.5 tuple
const expressionOptionTuple = Object.freeze({
    type: "reference",
    value: 5,
});
const expressionOptions = [
    { type: "option", key: ns.constant, value: expressionOptionConstant },
    { type: "option", key: ns.id, value: expressionOptionId },
    { type: "option", key: ns.injection, value: expressionOptionInjection },
    { type: "option", key: ns.node, value: expressionOptionNode },
    { type: "option", key: ns.path, value: expressionOptionPath },
    { type: "option", key: ns.tuple, value: expressionOptionTuple },
];
Object.freeze(expressionOptions);
for (const option of expressionOptions) {
    Object.freeze(option);
}
const expressionValue = Object.freeze({
    type: "coproduct",
    options: expressionOptions,
});
const expressionLabel = Object.freeze({
    type: "label",
    key: ns.expression,
    value: expressionValue,
});
// 3. match
const matchValue = Object.freeze({ type: "unit" });
const matchLabel = Object.freeze({
    type: "label",
    key: ns.match,
    value: matchValue,
});
// 4. path
const pathHeadOptions = [
    {
        type: "option",
        key: ns.dereference,
        value: Object.freeze({ type: "unit" }),
    },
    {
        type: "option",
        key: ns.match,
        value: Object.freeze({ type: "reference", value: 3 }),
    },
    { type: "option", key: ns.projection, value: Object.freeze({ type: "iri" }) },
];
Object.freeze(pathHeadOptions);
for (const option of pathHeadOptions) {
    Object.freeze(option);
}
const pathHead = Object.freeze({
    type: "coproduct",
    options: pathHeadOptions,
});
const pathTailOptions = [
    { type: "option", key: ns.none, value: Object.freeze({ type: "unit" }) },
    {
        type: "option",
        key: ns.some,
        value: Object.freeze({ type: "reference", value: 4 }),
    },
];
Object.freeze(pathTailOptions);
for (const option of pathTailOptions) {
    Object.freeze(option);
}
const pathTail = Object.freeze({
    type: "coproduct",
    options: pathTailOptions,
});
const pathComponents = [
    { type: "component", key: ns.head, value: pathHead },
    {
        type: "component",
        key: ns.tail,
        value: pathTail,
    },
];
Object.freeze(pathComponents);
for (const component of pathComponents) {
    Object.freeze(component);
}
const pathValue = Object.freeze({
    type: "product",
    components: pathComponents,
});
const pathLabel = Object.freeze({
    type: "label",
    key: ns.path,
    value: pathValue,
});
// 5. tuple
const tupleValue = Object.freeze({ type: "unit" });
const tupleLabel = Object.freeze({
    type: "label",
    key: ns.tuple,
    value: tupleValue,
});
const expressionSchema = [
    caseLabel,
    elementLabel,
    expressionLabel,
    matchLabel,
    pathLabel,
    tupleLabel,
];
Object.freeze(expressionSchema);
export default expressionSchema;
//# sourceMappingURL=expression.js.map