import { xsd } from "n3.ts"
import APG from "../apg.js"
import * as ns from "../namespace.js"

// The objects constructed here are extremely sensitive.
// Do NOT edit this file unless you absolutely know what you are doing.

// The six labels in the expression schema are:
// 0. case
// 1. element
// 2. expression
// 3. match
// 4. path
// 5. tuple

// We have to define them in alphabetical order.

// 0. case

const caseComponentKeyValue: APG.Iri = Object.freeze({ type: "iri" })
const caseComponentKey: APG.Component = Object.freeze({
	type: "component",
	key: ns.key,
	value: caseComponentKeyValue,
})

const caseComponentValueValue: APG.Reference = Object.freeze({
	type: "reference",
	value: 2,
})
const caseComponentValue: APG.Component = Object.freeze({
	type: "component",
	key: ns.value,
	value: caseComponentValueValue,
})

const caseValue: APG.Product = Object.freeze({
	type: "product",
	components: [caseComponentKey, caseComponentValue],
})

Object.freeze(caseValue.components)

const caseLabel: APG.Label = Object.freeze({
	type: "label",
	key: ns.CASE,
	value: caseValue,
})

// 1. element

const elementComponentKeyValue: APG.Iri = Object.freeze({ type: "iri" })
const elementComponentKey: APG.Component = Object.freeze({
	type: "component",
	key: ns.key,
	value: elementComponentKeyValue,
})

const elementComponentSourceValue: APG.Reference = Object.freeze({
	type: "reference",
	value: 5,
})

const elementComponentSource: APG.Component = Object.freeze({
	type: "component",
	key: ns.source,
	value: elementComponentSourceValue,
})

const elementComponentValueValue: APG.Reference = Object.freeze({
	type: "reference",
	value: 2,
})

const elementComponentValue: APG.Component = Object.freeze({
	type: "component",
	key: ns.value,
	value: elementComponentValueValue,
})

const elementValueComponents: APG.Component[] = [
	elementComponentKey,
	elementComponentSource,
	elementComponentValue,
]

Object.freeze(elementValueComponents)

const elementValue: APG.Product = Object.freeze({
	type: "product",
	components: elementValueComponents,
})

const elementLabel: APG.Label = Object.freeze({
	type: "label",
	key: ns.element,
	value: elementValue,
})

// 2. expression

// 2.0 constant

const expressionOptionConstantComponents: APG.Component[] = [
	{
		type: "component",
		key: ns.datatype,
		value: Object.freeze({ type: "iri" }),
	},
	{
		type: "component",
		key: ns.value,
		value: Object.freeze({ type: "literal", datatype: xsd.string }),
	},
]

Object.freeze(expressionOptionConstantComponents)
for (const component of expressionOptionConstantComponents) {
	Object.freeze(component)
}

const expressionOptionConstant: APG.Product = Object.freeze({
	type: "product",
	components: expressionOptionConstantComponents,
})

// 2.1 id

const expressionOptionId: APG.Iri = Object.freeze({ type: "iri" })

// 2.2 injection

const expressionOptionInjectionComponents: APG.Component[] = [
	{
		type: "component",
		key: ns.key,
		value: Object.freeze({ type: "iri" }),
	},
	{
		type: "component",
		key: ns.value,
		value: Object.freeze({ type: "reference", value: 2 }),
	},
]

Object.freeze(expressionOptionInjectionComponents)
for (const component of expressionOptionInjectionComponents) {
	Object.freeze(component)
}

const expressionOptionInjection: APG.Product = Object.freeze({
	type: "product",
	components: expressionOptionInjectionComponents,
})

// 2.3 node

const expressionOptionNode: APG.Unit = Object.freeze({ type: "unit" })

// 2.4 path

const expressionOptionPath: APG.Reference = Object.freeze({
	type: "reference",
	value: 4,
})

// 2.5 tuple

const expressionOptionTuple: APG.Reference = Object.freeze({
	type: "reference",
	value: 5,
})

const expressionOptions: APG.Option[] = [
	{ type: "option", key: ns.constant, value: expressionOptionConstant },
	{ type: "option", key: ns.id, value: expressionOptionId },
	{ type: "option", key: ns.injection, value: expressionOptionInjection },
	{ type: "option", key: ns.node, value: expressionOptionNode },
	{ type: "option", key: ns.path, value: expressionOptionPath },
	{ type: "option", key: ns.tuple, value: expressionOptionTuple },
]

Object.freeze(expressionOptions)
for (const option of expressionOptions) {
	Object.freeze(option)
}

const expressionValue: APG.Coproduct = Object.freeze({
	type: "coproduct",
	options: expressionOptions,
})

const expressionLabel: APG.Label = Object.freeze({
	type: "label",
	key: ns.expression,
	value: expressionValue,
})

// 3. match

const matchValue: APG.Unit = Object.freeze({ type: "unit" })

const matchLabel: APG.Label = Object.freeze({
	type: "label",
	key: ns.match,
	value: matchValue,
})

// 4. path

const pathHeadOptions: APG.Option[] = [
	{
		type: "option",
		key: ns.dereference,
		value: Object.freeze({ type: "unit" }),
	},
	{
		type: "option",
		key: ns.match,
		value: Object.freeze({ type: "reference", value: 3 }),
	},
	{ type: "option", key: ns.projection, value: Object.freeze({ type: "iri" }) },
]

Object.freeze(pathHeadOptions)
for (const option of pathHeadOptions) {
	Object.freeze(option)
}

const pathHead: APG.Coproduct = Object.freeze({
	type: "coproduct",
	options: pathHeadOptions,
})

const pathTailOptions: APG.Option[] = [
	{ type: "option", key: ns.none, value: Object.freeze({ type: "unit" }) },
	{
		type: "option",
		key: ns.some,
		value: Object.freeze({ type: "reference", value: 4 }),
	},
]

Object.freeze(pathTailOptions)
for (const option of pathTailOptions) {
	Object.freeze(option)
}

const pathTail: APG.Coproduct = Object.freeze({
	type: "coproduct",
	options: pathTailOptions,
})

const pathComponents: APG.Component[] = [
	{ type: "component", key: ns.head, value: pathHead },
	{
		type: "component",
		key: ns.tail,
		value: pathTail,
	},
]

Object.freeze(pathComponents)
for (const component of pathComponents) {
	Object.freeze(component)
}

const pathValue: APG.Product = Object.freeze({
	type: "product",
	components: pathComponents,
})

const pathLabel: APG.Label = Object.freeze({
	type: "label",
	key: ns.path,
	value: pathValue,
})

// 5. tuple

const tupleValue: APG.Unit = Object.freeze({ type: "unit" })

const tupleLabel: APG.Label = Object.freeze({
	type: "label",
	key: ns.tuple,
	value: tupleValue,
})

const expressionSchema: readonly [
	typeof caseLabel,
	typeof elementLabel,
	typeof expressionLabel,
	typeof matchLabel,
	typeof pathLabel,
	typeof tupleLabel
] = [
	caseLabel,
	elementLabel,
	expressionLabel,
	matchLabel,
	pathLabel,
	tupleLabel,
]

Object.freeze(expressionSchema)

export default expressionSchema
