import { xsd } from "n3.ts"

import APG from "../../apg.js"
import * as ns from "../../namespace.js"

// The objects constructed here are extremely sensitive.
// Do NOT edit this file unless you absolutely know what you are doing.

// The six labels in the expression schema are:
// 0. case
// 1. expression
// 2. map
// 3. match
// 4. path
// 5. slot
// 6. tuple

// We have to define them in alphabetical order.

/// But first, let's define some re-used values
const pathTailOptions: APG.Option[] = [
	{ type: "option", key: ns.none, value: Object.freeze({ type: "unit" }) },
	{
		type: "option",
		key: ns.some,
		value: Object.freeze({ type: "reference", value: 4 }),
	},
]

Object.freeze(pathTailOptions)
for (const option of pathTailOptions) {
	Object.freeze(option)
}

const pathTailValue: APG.Coproduct = Object.freeze({
	type: "coproduct",
	options: pathTailOptions,
})

// Okay, now let's do it
// 0. case

const caseComponentKeyValue: APG.Iri = Object.freeze({ type: "iri" })
const caseComponentKey: APG.Component = Object.freeze({
	type: "component",
	key: ns.key,
	value: caseComponentKeyValue,
})

const caseComponentSourceValue: APG.Reference = Object.freeze({
	type: "reference",
	value: 3,
})

const caseComponentSource: APG.Component = Object.freeze({
	type: "component",
	key: ns.source,
	value: caseComponentSourceValue,
})

const caseComponentValueValue: APG.Reference = Object.freeze({
	type: "reference",
	value: 1,
})
const caseComponentValue: APG.Component = Object.freeze({
	type: "component",
	key: ns.value,
	value: caseComponentValueValue,
})

const caseValue: APG.Product = Object.freeze({
	type: "product",
	components: [caseComponentKey, caseComponentSource, caseComponentValue],
})

Object.freeze(caseValue.components)

const caseLabel: APG.Label = Object.freeze({
	type: "label",
	key: ns.CASE,
	value: caseValue,
})

// 1. expression

// What can an expression be?
// We'll it's definitely a linked list, so its tail is null | Expression.
// It's head is one of these:
// 1.0 Constant
// 1.1 Dereference
// 1.2 Identifier
// 1.3 Identity
// 1.4 Initial
// 1.5 Injection
// 1.6 Match
// 1.7 Projection
// 1.8 Terminal
// 1.9 Tuple

// 1.0 constant

const expressionOptionConstantComponents: APG.Component[] = [
	{
		type: "component",
		key: ns.datatype,
		value: Object.freeze({ type: "iri" }),
	},
	{
		type: "component",
		key: ns.value,
		value: Object.freeze({ type: "literal", datatype: xsd.string }),
	},
]

Object.freeze(expressionOptionConstantComponents)
for (const component of expressionOptionConstantComponents) {
	Object.freeze(component)
}

const expressionOptionConstant: APG.Product = Object.freeze({
	type: "product",
	components: expressionOptionConstantComponents,
})

// 1.1 dereference

const expressionOptionDereference: APG.Iri = Object.freeze({ type: "iri" })

// 1.2 identifier

const expressionOptionIdentifier: APG.Iri = Object.freeze({ type: "iri" })

// 1.3 identity

const expressionOptionIdentity: APG.Unit = Object.freeze({ type: "unit" })

// 1.4 initial

const expressionOptionInitial: APG.Unit = Object.freeze({ type: "unit" })

// 1.5 injection

const expressionOptionInjectionComponents: APG.Component[] = [
	{
		type: "component",
		key: ns.key,
		value: Object.freeze({ type: "iri" }),
	},
	{
		type: "component",
		key: ns.value,
		value: Object.freeze({ type: "reference", value: 1 }),
	},
]

Object.freeze(expressionOptionInjectionComponents)
for (const component of expressionOptionInjectionComponents) {
	Object.freeze(component)
}

const expressionOptionInjection: APG.Product = Object.freeze({
	type: "product",
	components: expressionOptionInjectionComponents,
})

// 1.6 match

const expressionOptionMatch: APG.Reference = Object.freeze({
	type: "reference",
	value: 3,
})

// 1.7 projection

const expressionOptionProjection: APG.Iri = Object.freeze({ type: "iri" })

// 1.8 terminal

const expressionOptionTerminal: APG.Unit = Object.freeze({ type: "unit" })

// 1.9 tuple

const expressionOptionTuple: APG.Reference = Object.freeze({
	type: "reference",
	value: 6,
})

const expressionOptions: APG.Option[] = [
	{ type: "option", key: ns.constant, value: expressionOptionConstant },
	{ type: "option", key: ns.dereference, value: expressionOptionDereference },
	{ type: "option", key: ns.identifier, value: expressionOptionIdentifier },
	{ type: "option", key: ns.identity, value: expressionOptionIdentity },
	{ type: "option", key: ns.initial, value: expressionOptionInitial },
	{ type: "option", key: ns.injection, value: expressionOptionInjection },
	{ type: "option", key: ns.match, value: expressionOptionMatch },
	{ type: "option", key: ns.projection, value: expressionOptionProjection },
	{ type: "option", key: ns.terminal, value: expressionOptionTerminal },
	{ type: "option", key: ns.tuple, value: expressionOptionTuple },
]

Object.freeze(expressionOptions)
for (const option of expressionOptions) {
	Object.freeze(option)
}

const expressionValue: APG.Coproduct = Object.freeze({
	type: "coproduct",
	options: expressionOptions,
})

const expressionLabel: APG.Label = Object.freeze({
	type: "label",
	key: ns.expression,
	value: expressionValue,
})

// 2. map

const mapComponents: APG.Component[] = [
	{ type: "component", key: ns.key, value: Object.freeze({ type: "iri" }) },
	{ type: "component", key: ns.source, value: Object.freeze({ type: "iri" }) },
	{
		type: "component",
		key: ns.target,
		value: pathTailValue,
	},
	{
		type: "component",
		key: ns.value,
		value: Object.freeze({ type: "reference", value: 1 }),
	},
]

Object.freeze(mapComponents)
for (const component of mapComponents) {
	Object.freeze(component)
}

const mapValue: APG.Product = Object.freeze({
	type: "product",
	components: mapComponents,
})

const mapLabel: APG.Label = Object.freeze({
	type: "label",
	key: ns.map,
	value: mapValue,
})

// 3. match

const matchValue: APG.Unit = Object.freeze({ type: "unit" })

const matchLabel: APG.Label = Object.freeze({
	type: "label",
	key: ns.match,
	value: matchValue,
})

// 4. path

const pathHeadOptions: APG.Option[] = [
	{ type: "option", key: ns.component, value: Object.freeze({ type: "iri" }) },
	{ type: "option", key: ns.option, value: Object.freeze({ type: "iri" }) },
]

Object.freeze(pathHeadOptions)
for (const option of pathHeadOptions) {
	Object.freeze(option)
}

const pathComponents: APG.Component[] = [
	{
		type: "component",
		key: ns.head,
		value: Object.freeze({ type: "coproduct", options: pathHeadOptions }),
	},
	{ type: "component", key: ns.tail, value: pathTailValue },
]

Object.freeze(pathComponents)
for (const component of pathComponents) {
	Object.freeze(component)
}

const pathValue: APG.Product = Object.freeze({
	type: "product",
	components: pathComponents,
})

const pathLabel: APG.Label = Object.freeze({
	type: "label",
	key: ns.path,
	value: pathValue,
})

// 5. slot

const slotComponentKeyValue: APG.Iri = Object.freeze({ type: "iri" })
const slotComponentKey: APG.Component = Object.freeze({
	type: "component",
	key: ns.key,
	value: slotComponentKeyValue,
})

const slotComponentSourceValue: APG.Reference = Object.freeze({
	type: "reference",
	value: 6,
})

const slotComponentSource: APG.Component = Object.freeze({
	type: "component",
	key: ns.source,
	value: slotComponentSourceValue,
})

const slotComponentValueValue: APG.Reference = Object.freeze({
	type: "reference",
	value: 1,
})

const slotComponentValue: APG.Component = Object.freeze({
	type: "component",
	key: ns.value,
	value: slotComponentValueValue,
})

const slotValueComponents: APG.Component[] = [
	slotComponentKey,
	slotComponentSource,
	slotComponentValue,
]

Object.freeze(slotValueComponents)

const slotValue: APG.Product = Object.freeze({
	type: "product",
	components: slotValueComponents,
})

const slotLabel: APG.Label = Object.freeze({
	type: "label",
	key: ns.slot,
	value: slotValue,
})

// 6. tuple

const tupleValue: APG.Unit = Object.freeze({ type: "unit" })

const tupleLabel: APG.Label = Object.freeze({
	type: "label",
	key: ns.tuple,
	value: tupleValue,
})

const mappingSchema: readonly [
	typeof caseLabel,
	typeof expressionLabel,
	typeof mapLabel,
	typeof matchLabel,
	typeof pathLabel,
	typeof slotLabel,
	typeof tupleLabel
] = [
	caseLabel,
	expressionLabel,
	mapLabel,
	matchLabel,
	pathLabel,
	slotLabel,
	tupleLabel,
]

Object.freeze(mappingSchema)

export default mappingSchema
